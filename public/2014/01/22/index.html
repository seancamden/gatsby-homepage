<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.0.85"/><title data-react-helmet="true"></title><link rel="shortcut icon" href="/seancamden.github.io/icons/icon-48x48.png"/><link rel="manifest" href="/seancamden.github.io/manifest.webmanifest"/><meta name="theme-color" content="#663399"/><link as="script" rel="preload" href="/seancamden.github.io/component---src-templates-blog-template-js-bacb1173d606c869dec8.js"/><link as="script" rel="preload" href="/seancamden.github.io/app-58e040dd602d36db93b2.js"/><link as="script" rel="preload" href="/seancamden.github.io/webpack-runtime-acc43d9c669c6bb72159.js"/><link as="fetch" rel="preload" href="/seancamden.github.io/static/d/34/path---2014-01-22-415-884-0DfmSyzHKIQWdZKqnqJUwbs8M1s.json" crossOrigin="use-credentials"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group"><div class="blog-post-container"><div class="blog-post"><h1>Playing with TextBlob</h1><h2>January 22, 2014</h2><div class="blog-post-content"><p>TextBlob is a fun Python library that allows one to parse blocks of text in neat ways.</p>
<p>To use it, all you need is a computer with <a href="http://www.python.org/">Python</a> on it. I’m using <a href="http://linuxmint.com/">Linux Mint</a> with Python 2.7.3. Installation of TextBlob is covered pretty well on <a href="http://textblob.readthedocs.org/en/latest/">Steve Loria’s TextBlob page</a>.</p>
<p>To begin I open my Python interpreter and import TextBlob.</p>
<p><code>>>> from textblob import TextBlob</code></p>
<p>Then I load my text. I’m using a chunk of <a href="http://www.gutenberg.org/ebooks/28054">The Brothers Karamazov</a>.</p>
<p><code>>>> with open(r"/home/sean/Documents/text-blobs/the-brothers-karamazov/brothers-044") as infile:&#x3C;br /> ... &#x26;nbsp;&#x26;nbsp;data = infile.read()&#x3C;br /> ... &#x26;nbsp;&#x26;nbsp;myblob = TextBlob(data)&#x3C;br /> ...&#x3C;br /></code> </p>
<p>Now I have a TextBlob object named “myblob” and I can do fun stuff with it. For instance, I can loop through it and pull out all the adjectives.</p>
<p><code>>>> for value,key in sorted(set(myblob.tags)):&#x3C;br /> ... &#x26;nbsp;&#x26;nbsp;if key == "JJ":&#x3C;br /> ... &#x26;nbsp;&#x26;nbsp;&#x26;nbsp;&#x26;nbsp;print key,value&#x3C;br /> ...&#x3C;br /> JJ back&#x3C;br /> JJ back-way&#x3C;br /> JJ black&#x3C;br /> JJ certain&#x3C;br /> JJ civil&#x3C;br /> JJ clear&#x3C;br /> --and so on...&#x3C;br /></code> </p>
<p>By setting up my <code>for</code> loop with the <code>sorted()</code> and <code>set()</code> methods, the output is alphabetized and will contain no duplicates.</p>
<p>But suppose I only want to see the adjectives that are five characters long. Then I use Python’s <code>len()</code> method. Like so:</p>
<p><code>>>> for value,key in sorted(set(myblob.tags)):&#x3C;br /> ... &#x26;nbsp;&#x26;nbsp;if key == "JJ" and len(value) == 5:&#x3C;br /> ... &#x26;nbsp;&#x26;nbsp;&#x26;nbsp;&#x26;nbsp;print key,value&#x3C;br /> ...&#x3C;br /> JJ black&#x3C;br /> JJ civil&#x3C;br /> JJ clear&#x3C;br /> JJ equal&#x3C;br /> JJ first&#x3C;br /> --and so on...&#x3C;br /></code> </p>
<p>I can sort for verbs, too; in fact, any part of speech listed in the <a href="http://www.clips.ua.ac.be/pages/mbsp-tags">Penn Treebank II tag set</a> will work.</p>
<p>The Penn Treebank code for gerunds is VBG. But sometimes I want all the words that end in “ing” even if it’s not a gerund. In that case, I use Python’s string methods instead. Like so:</p>
<p><code>>>> for value,key in sorted(set(myblob.tags)):&#x3C;br /> ... &#x26;nbsp;&#x26;nbsp;if value[-3:] == "ing":&#x3C;br /> ... &#x26;nbsp;&#x26;nbsp;&#x26;nbsp;&#x26;nbsp;print key,value&#x3C;br /> ...&#x3C;br /> VBG according&#x3C;br /> NN anything&#x3C;br /> VBG behaving&#x3C;br /> VBG bringing&#x3C;br /> --and so on...&#x3C;br /></code> </p>
<p>Using Python’s handy string methods I can easily test for a word that begins with a particular letter, too. Here I’ll throw in the <code>lower()</code> method to match regardless of case:</p>
<p><code>>>> for value,key in sorted(set(myblob.tags)):&#x3C;br /> ... &#x26;nbsp;&#x26;nbsp;if value[0].lower() == "a":&#x3C;br /> ... &#x26;nbsp;&#x26;nbsp;&#x26;nbsp;&#x26;nbsp;print key,value&#x3C;br /> ...&#x3C;br /> DT A&#x3C;br /> IN Among&#x3C;br /> NNP April&#x3C;br /> IN At&#x3C;br /> DT a&#x3C;br /> IN about&#x3C;br /> VBG according&#x3C;br /> VBN accustomed&#x3C;br /> --and so on...&#x3C;br /></code> </p>
<p>But what if I want to match all the words that start with vowels? Well, I think I’m going to need a <a href="http://www.regular-expressions.info/">regular expression</a> to do that. (I love regular expressions.)</p>
<p>First I’ll import Python’s regex library and then create my regular expression.</p>
<p>`>>> import re<br /></p>
<blockquote>
<blockquote>
<blockquote>
<p>reg = re.compile('^[aeiou]\w*', re.IGNORECASE)<br />
` </p>
</blockquote>
</blockquote>
</blockquote>
<p>As you can see, I’m looking for any word that begins “<code>^</code>” with a vowel “<code>[aeiou]</code>” and is followed by zero or more “<code>*</code>” alphanumeric characters “<code>\w</code>” and I want to ignore case. Then I just use another <code>for</code> loop, only this time with my new regex. Like so:</p>
<p><code>>>> for value,key in sorted(set(myblob.tags)):&#x3C;br /> ... &#x26;nbsp;&#x26;nbsp;if reg.match(value):&#x3C;br /> ... &#x26;nbsp;&#x26;nbsp;&#x26;nbsp;&#x26;nbsp;print key,value&#x3C;br /> ...&#x3C;br /> DT A&#x3C;br /> IN Among&#x3C;br /> NNP April&#x3C;br /> IN At&#x3C;br /> DT Every&#x3C;br /> IN If&#x3C;br /> IN In&#x3C;br /> PRP It&#x3C;br /> IN Of&#x3C;br /> DT a&#x3C;br /> IN about&#x3C;br /> --and so on...&#x3C;br /></code> </p>
<p>All the base form verbs that start with a vowel:</p>
<p><code>>>> for value,key in sorted(set(myblob.tags)):&#x3C;br /> ... &#x26;nbsp;&#x26;nbsp;if key == "VB" and reg.match(value):&#x3C;br /> ... &#x26;nbsp;&#x26;nbsp;&#x26;nbsp;&#x26;nbsp;print key,value&#x3C;br /> ...&#x3C;br /> VB act&#x3C;br /> VB entertain&#x3C;br /> VB estrange&#x3C;br /> VB in&#x3C;br /> VB into&#x3C;br /></code> </p>
<p>Pretty cool, right?</p></div></div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-templates-blog-template-js","jsonName":"2014-01-22-415","path":"/2014/01/22"};window.dataPath="34/path---2014-01-22-415-884-0DfmSyzHKIQWdZKqnqJUwbs8M1s";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-58e040dd602d36db93b2.js"],"component---node-modules-gatsby-plugin-offline-app-shell-js":["/component---node-modules-gatsby-plugin-offline-app-shell-js-4761d21acac1f87e8392.js"],"component---src-templates-blog-template-js":["/component---src-templates-blog-template-js-bacb1173d606c869dec8.js"],"component---src-pages-404-js":["/component---src-pages-404-js-690981ec0d9c088c6b2d.js"],"component---src-pages-index-js":["/component---src-pages-index-js-4dba50d597cbbea10715.js"],"component---src-pages-page-2-js":["/component---src-pages-page-2-js-c7a21650b2020135978e.js"],"pages-manifest":["/pages-manifest-77d4778944a9efc30d68.js"]};/*]]>*/</script><script src="/seancamden.github.io/webpack-runtime-acc43d9c669c6bb72159.js" async=""></script><script src="/seancamden.github.io/app-58e040dd602d36db93b2.js" async=""></script><script src="/seancamden.github.io/component---src-templates-blog-template-js-bacb1173d606c869dec8.js" async=""></script></body></html>